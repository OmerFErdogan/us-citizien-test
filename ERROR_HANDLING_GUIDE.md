# Error Handling Integration Guide

## üöÄ Improved Error Handling Implementation

Bu kƒ±lavuz, ABD Vatanda≈ülƒ±k Test uygulamanƒ±za geli≈ümi≈ü error handling sisteminin nasƒ±l entegre edileceƒüini a√ßƒ±klar.

## üìÅ Dosya Yapƒ±sƒ±

```
lib/
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îî‚îÄ‚îÄ exceptions/
‚îÇ       ‚îú‚îÄ‚îÄ app_exceptions.dart       # Custom exception classes
‚îÇ       ‚îî‚îÄ‚îÄ error_handler_service.dart # Global error handler
‚îú‚îÄ‚îÄ widgets/
‚îÇ   ‚îî‚îÄ‚îÄ error/
‚îÇ       ‚îî‚îÄ‚îÄ error_widgets.dart        # Error UI components
‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îî‚îÄ‚îÄ improved_question_service.dart # Updated service with error handling
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îî‚îÄ‚îÄ error_handling_examples.dart  # Usage examples
‚îî‚îÄ‚îÄ improved_main.dart                # Updated main.dart with global error handling
```

## üîß 1. Mevcut Kodu G√ºncelleme

### Adƒ±m 1: Dependencies Ekleme
`pubspec.yaml` dosyanƒ±za ≈üu dependency'leri ekleyin:

```yaml
dependencies:
  # ... mevcut dependencies
  connectivity_plus: ^5.0.2  # Network status i√ßin
  device_info_plus: ^10.1.0  # Device info i√ßin
```

### Adƒ±m 2: QuestionService'i Deƒüi≈ütirme

Mevcut `QuestionService`'inizi `ImprovedQuestionService` ile deƒüi≈ütirin:

```dart
// Eski kullanƒ±m
final questionService = QuestionService();

// Yeni kullanƒ±m
final questionService = ImprovedQuestionService();
```

### Adƒ±m 3: Main.dart G√ºncelleme

Mevcut `main.dart` dosyanƒ±zƒ± `improved_main.dart` ile deƒüi≈ütirin:

```dart
// Import ekleyin
import 'utils/exceptions/error_handler_service.dart';
import 'utils/exceptions/app_exceptions.dart';
import 'widgets/error/error_widgets.dart';
```

## üéØ 2. Error Types ve Kullanƒ±m

### Temel Exception Types

```dart
// Network errors
NetworkException(
  message: 'No internet connection',
  code: 'NETWORK_ERROR'
)

// Data errors
DataException(
  message: 'Invalid data format',
  code: 'DATA_ERROR'
)

// Storage errors
StorageException(
  message: 'Storage access failed',
  code: 'STORAGE_ERROR'
)

// Validation errors
ValidationException(
  message: 'Invalid input',
  code: 'VALIDATION_ERROR'
)

// Service errors
ServiceException(
  message: 'Service initialization failed',
  code: 'SERVICE_ERROR'
)
```

### Error Severity Levels

```dart
ErrorSeverity.low     // Snackbar g√∂ster
ErrorSeverity.medium  // Dialog g√∂ster, retry se√ßeneƒüi
ErrorSeverity.high    // Kritik dialog, app restart √∂nerisi
ErrorSeverity.critical // App'i zorla kapat
```

## üî• 3. Pratik Kullanƒ±m √ñrnekleri

### Widget'larda Error Handling

```dart
class MyWidget extends StatefulWidget {
  @override
  _MyWidgetState createState() => _MyWidgetState();
}

class _MyWidgetState extends State<MyWidget> {
  final ErrorHandlerService _errorHandler = ErrorHandlerService();
  
  Future<void> _loadData() async {
    try {
      // Veri y√ºkleme i≈ülemi
      final data = await dataService.loadData();
      setState(() {
        // UI g√ºncelleme
      });
    } catch (e, stackTrace) {
      await _errorHandler.handleError(
        exception: ErrorHandlerService.convertException(e, stackTrace),
        stackTrace: stackTrace,
        severity: ErrorSeverity.medium,
        buildContext: context,
        context: {
          'widget': 'MyWidget',
          'operation': 'loadData',
        },
      );
    }
  }
}
```

### Async Operations

```dart
Future<void> _submitAnswer(String answer) async {
  try {
    // Input validation
    if (answer.trim().isEmpty) {
      throw ValidationException(
        message: 'Please select an answer',
        code: 'EMPTY_ANSWER',
      );
    }
    
    await questionService.answerQuestion(questionId, answer);
    _showSuccess('Answer submitted!');
    
  } catch (e, stackTrace) {
    await _errorHandler.handleError(
      exception: e is AppException 
          ? e 
          : ErrorHandlerService.convertException(e, stackTrace),
      stackTrace: stackTrace,
      severity: ErrorSeverity.medium,
      buildContext: context,
    );
  }
}
```

### Loading States with Error Handling

```dart
@override
Widget build(BuildContext context) {
  return LoadingWithErrorWidget(
    future: _loadQuestions(),
    builder: (context, data) {
      return QuestionsList(questions: data);
    },
    errorBuilder: (context, error) {
      return ErrorDisplayWidget(
        exception: error,
        onRetry: _retryLoad,
      );
    },
    loadingWidget: const LoadingIndicator(),
  );
}
```

## üì± 4. UI Error Components

### ErrorDisplayWidget

```dart
ErrorDisplayWidget(
  exception: exception,
  onRetry: _retryOperation,        // ƒ∞steƒüe baƒülƒ± retry fonksiyonu
  customMessage: 'Custom error',   // ƒ∞steƒüe baƒülƒ± √∂zel mesaj
  showDetails: true,               // Error code g√∂ster
)
```

### LoadingWithErrorWidget

```dart
LoadingWithErrorWidget(
  future: dataLoadingFuture,
  builder: (context, data) => SuccessWidget(data),
  errorBuilder: (context, error) => CustomErrorWidget(error),
  loadingWidget: CustomLoadingWidget(),
)
```

### ErrorBoundary

```dart
ErrorBoundary(
  errorBuilder: (context, error, stackTrace) {
    return ErrorPage(error: error);
  },
  child: YourMainWidget(),
)
```

## üîÑ 5. Error Recovery Strategies

### Retry Mechanisms

```dart
class RetryableOperation {
  static const int maxRetries = 3;
  static const Duration retryDelay = Duration(seconds: 2);
  
  static Future<T> withRetry<T>(
    Future<T> Function() operation,
    {int maxAttempts = maxRetries}
  ) async {
    int attempts = 0;
    
    while (attempts < maxAttempts) {
      try {
        return await operation();
      } catch (e) {
        attempts++;
        if (attempts >= maxAttempts) rethrow;
        
        await Future.delayed(retryDelay * attempts);
      }
    }
    
    throw Exception('Max retry attempts exceeded');
  }
}

// Kullanƒ±m
await RetryableOperation.withRetry(() => 
  questionService.loadQuestions()
);
```

### Fallback Data

```dart
class DataService {
  Future<List<Question>> loadQuestions() async {
    try {
      return await _loadFromNetwork();
    } catch (e) {
      try {
        return await _loadFromCache();
      } catch (e2) {
        return _getDefaultQuestions();
      }
    }
  }
  
  List<Question> _getDefaultQuestions() {
    // Fallback questions
    return [/* default questions */];
  }
}
```

## üìä 6. Error Analytics ve Monitoring

### Error Reporting

```dart
// Production'da error reporting
if (kReleaseMode) {
  await FirebaseCrashlytics.instance.recordError(
    exception,
    stackTrace,
    fatal: severity == ErrorSeverity.critical,
  );
}
```

### Error Metrics

```dart
class ErrorMetrics {
  static final Map<String, int> _errorCounts = {};
  
  static void recordError(String errorCode) {
    _errorCounts[errorCode] = (_errorCounts[errorCode] ?? 0) + 1;
  }
  
  static Map<String, int> getErrorStats() => _errorCounts;
}
```

## üß™ 7. Testing Error Handling

### Unit Tests

```dart
test('should handle network error gracefully', () async {
  // Arrange
  when(mockNetworkService.getData())
      .thenThrow(SocketException('No internet'));
  
  // Act
  await service.loadData();
  
  // Assert
  verify(mockErrorHandler.handleError(
    exception: any(named: 'exception'),
    severity: ErrorSeverity.medium,
  ));
});
```

### Widget Tests

```dart
testWidgets('should show error widget on data load failure', (tester) async {
  // Arrange
  when(mockService.loadData()).thenThrow(DataException(
    message: 'Load failed',
    code: 'LOAD_ERROR',
  ));
  
  // Act
  await tester.pumpWidget(MyWidget());
  await tester.pump();
  
  // Assert
  expect(find.byType(ErrorDisplayWidget), findsOneWidget);
  expect(find.text('Load failed'), findsOneWidget);
});
```

## üöÄ 8. Performance Considerations

### Error Handler Optimization

```dart
class OptimizedErrorHandler {
  static const int maxErrorsPerMinute = 10;
  final List<DateTime> _recentErrors = [];
  
  Future<void> handleError(AppException exception) async {
    // Rate limiting
    _cleanOldErrors();
    
    if (_recentErrors.length >= maxErrorsPerMinute) {
      debugPrint('Error rate limit exceeded, dropping error');
      return;
    }
    
    _recentErrors.add(DateTime.now());
    
    // Handle error
    await _processError(exception);
  }
  
  void _cleanOldErrors() {
    final cutoff = DateTime.now().subtract(const Duration(minutes: 1));
    _recentErrors.removeWhere((time) => time.isBefore(cutoff));
  }
}
```

## üîÑ 9. Migration Steps

### Mevcut Koddan Ge√ßi≈ü

1. **Exception Classes Ekle**
   ```dart
   // Eski
   throw Exception('Error message');
   
   // Yeni
   throw DataException(
     message: 'Error message',
     code: 'ERROR_CODE',
   );
   ```

2. **Try-Catch Bloklarƒ± G√ºncelle**
   ```dart
   // Eski
   try {
     await operation();
   } catch (e) {
     print('Error: $e');
   }
   
   // Yeni
   try {
     await operation();
   } catch (e, stackTrace) {
     await _errorHandler.handleError(
       exception: ErrorHandlerService.convertException(e, stackTrace),
       stackTrace: stackTrace,
       severity: ErrorSeverity.medium,
       buildContext: context,
     );
   }
   ```

3. **UI Error States Ekle**
   ```dart
   // Loading/Error states i√ßin ErrorDisplayWidget kullan
   if (hasError) {
     return ErrorDisplayWidget(
       exception: error,
       onRetry: _retryOperation,
     );
   }
   ```

## ‚úÖ 10. Best Practices

### Do's ‚úÖ

- **Specific Exception Types**: Her error type i√ßin uygun exception class kullanƒ±n
- **User-Friendly Messages**: Teknik detaylarƒ± gizleyin, kullanƒ±cƒ± dostu mesajlar g√∂sterin
- **Retry Mechanisms**: Network ve ge√ßici errorlar i√ßin retry se√ßeneƒüi sunun
- **Context Information**: Error handling'de context bilgisi ekleyin
- **Analytics**: Production'da error tracking kullanƒ±n

### Don'ts ‚ùå

- **Generic Exceptions**: `Exception('error')` gibi generic exceptionlar kullanmayƒ±n
- **Silent Failures**: Errorlarƒ± g√∂rmezden gelmeyin
- **Technical Messages**: Kullanƒ±cƒ±ya stack trace g√∂stermeyin
- **Blocking UI**: Critical olmayan errorlar i√ßin app'i bloklamayƒ±n
- **Over-Handling**: Her k√º√ß√ºk error i√ßin dialog g√∂stermeyin

## üèÅ Sonu√ß

Bu error handling sistemi ile:
- ‚úÖ Daha iyi kullanƒ±cƒ± deneyimi
- ‚úÖ Kolay debugging ve maintenance
- ‚úÖ Production'da error tracking
- ‚úÖ Graceful error recovery
- ‚úÖ Consistent error UI

Sistemi kademeli olarak entegre edin ve test edin. Sorularƒ±nƒ±z i√ßin documentation'a ba≈üvurun.
